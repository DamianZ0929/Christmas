<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Magic Christmas - Hold to Summon</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000000; 
            font-family: 'Segoe UI', sans-serif; 
            cursor: pointer;
        }
        canvas { display: block; }
        
        #loading {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%);
            color: #fff; font-size: 20px; font-weight: bold;
            pointer-events: none; text-shadow: 0 0 10px red;
        }

        .hint {
            position: absolute; bottom: 30px; 
            width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px; letter-spacing: 3px;
            text-shadow: 0 0 15px rgba(255,215,0, 0.6);
            pointer-events: none;
            text-transform: uppercase;
            font-weight: bold;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="loading">加载资源中...</div>
    <div class="hint">✨ 按住鼠标 召唤圣诞树 ✨</div>

    <script>
        window.onload = function() {
            document.getElementById('loading').style.display = 'none';
            init();
        };

        const CONFIG = {
            particleCount: 22000,
            baseSize: 1.8,
            treeHeight: 24,
            treeRadius: 10,
            text: "MERRY CHRISTMAS",
            colors: {
                green: 0x00A500, red: 0xFF0033, gold: 0xFFD700, white: 0xFFFFFF, blue: 0x00CCFF
            }
        };

        let scene, camera, renderer, particlesMesh;
        let isInteracting = false; // 默认为 false (松开状态)
        let time = 0;
        
        let geometry, material;
        let positions, targets, colors, sizes, shapes;
        // 新增：用于打散时的随机目标点
        let scatterTargets; 

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020202, 0.015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 40); 
            camera.lookAt(0, 6, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            const texStar = createShapeTexture('star');
            const texHeart = createShapeTexture('heart');

            geometry = new THREE.BufferGeometry();
            const count = CONFIG.particleCount;
            
            positions = new Float32Array(count * 3);
            targets = new Float32Array(count * 3);
            scatterTargets = new Float32Array(count * 3); // 存储打散状态的目标点
            colors = new Float32Array(count * 3);
            sizes = new Float32Array(count);
            shapes = new Float32Array(count);

            const treeCount = Math.floor(count * 0.75);
            const textCount = count - treeCount;
            const treePoints = generateTreePoints(treeCount);
            const textPoints = generateBottomTextPoints(CONFIG.text, textCount);
            const allTargets = [...treePoints, ...textPoints];

            for (let i = 0; i < count; i++) {
                // 1. 初始位置 / 打散位置 (全屏随机分布，无规律，非圆圈)
                const sx = (Math.random()-0.5)*150;
                const sy = (Math.random()-0.5)*150;
                const sz = (Math.random()-0.5)*100;

                positions[i*3] = sx;
                positions[i*3+1] = sy;
                positions[i*3+2] = sz;

                // 记录这个随机点，作为“松开鼠标”时的目标
                scatterTargets[i*3] = sx;
                scatterTargets[i*3+1] = sy;
                scatterTargets[i*3+2] = sz;

                // 2. 树/文字的聚合目标位置
                if (i < allTargets.length) {
                    const t = allTargets[i];
                    targets[i*3] = t.x; targets[i*3+1] = t.y; targets[i*3+2] = t.z;
                    
                    colors[i*3] = t.r; colors[i*3+1] = t.g; colors[i*3+2] = t.b;
                    sizes[i] = t.size;

                    if (t.r > 0.8 && t.g < 0.4) shapes[i] = 1.0; 
                    else shapes[i] = (Math.random()>0.8) ? 1.0 : 0.0;
                } else {
                    sizes[i] = 0;
                }
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('target', new THREE.BufferAttribute(targets, 3));
            geometry.setAttribute('scatterTarget', new THREE.BufferAttribute(scatterTargets, 3)); // 传递给Shader或JS用
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('shape', new THREE.BufferAttribute(shapes, 1));

            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uStar: { value: texStar },
                    uHeart: { value: texHeart }
                },
                vertexShader: `
                    attribute float size; attribute vec3 color; attribute float shape;
                    attribute vec3 target; 
                    varying vec3 vColor; varying float vShape; 
                    uniform float uTime;

                    void main() {
                        vColor = color; vShape = shape;
                        vec3 pos = position;

                        // 只有当粒子接近"树"的形态时(即聚合时)，才应用律动
                        // 我们通过判断当前位置和目标的距离来粗略决定
                        // 但为了简单，我们让Shader始终计算律动，但通过 JS 动画逻辑控制位置
                        
                        // 律动逻辑：
                        if (target.y > -2.0) { // 树身
                            float breath = 1.0 + sin(uTime * 3.0) * 0.05;
                            pos.x *= breath;
                            pos.z *= breath;
                            
                            float twist = sin(uTime * 2.0 + pos.y * 0.3) * 0.3;
                            pos.x += twist;
                            pos.z += cos(uTime * 2.0 + pos.y * 0.3) * 0.3;
                        } else { // 底部文字
                            pos.y += sin(uTime * 2.0 + pos.x * 0.1) * 0.2;
                        }

                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        float blink = 1.0 + sin(uTime * 5.0 + pos.y) * 0.2;
                        gl_PointSize = (size * blink) * (800.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform sampler2D uStar; uniform sampler2D uHeart;
                    varying vec3 vColor; varying float vShape;
                    void main() {
                        vec4 tex = (vShape > 0.5) ? texture2D(uHeart, gl_PointCoord) : texture2D(uStar, gl_PointCoord);
                        if (tex.a < 0.1) discard;
                        gl_FragColor = vec4(vColor * 1.8, tex.a);
                    }
                `,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });

            particlesMesh = new THREE.Points(geometry, material);
            scene.add(particlesMesh);

            initInput();
            window.addEventListener('resize', onResize);
            animate();
        }

        function initInput() {
            // 按下 -> 聚合
            document.addEventListener('mousedown', () => { isInteracting = true; });
            document.addEventListener('touchstart', (e) => { isInteracting = true; e.preventDefault(); }, {passive:false});
            
            // 松开 -> 打散
            document.addEventListener('mouseup', () => { isInteracting = false; });
            document.addEventListener('touchend', () => { isInteracting = false; });
        }

        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.015;
            material.uniforms.uTime.value = time;

            const pa = geometry.attributes.position.array;
            const ta = geometry.attributes.target.array;     // 树的形态
            const sa = geometry.attributes.scatterTarget.array; // 打散的随机形态

            // 旋转逻辑：打散时慢转，聚合时快转
            if (!isInteracting) particlesMesh.rotation.y += 0.002; 
            else particlesMesh.rotation.y = THREE.MathUtils.lerp(particlesMesh.rotation.y, 0, 0.05);

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const idx = i * 3;
                const cx = pa[idx], cy = pa[idx+1], cz = pa[idx+2];
                let tx, ty, tz;

                if (isInteracting) {
                    // === 按住鼠标：聚合成树 ===
                    tx = ta[idx]; 
                    ty = ta[idx+1]; 
                    tz = ta[idx+2];
                    
                    // 快速磁力吸附效果
                    pa[idx] += (tx - cx) * 0.08;
                    pa[idx+1] += (ty - cy) * 0.08;
                    pa[idx+2] += (tz - cz) * 0.08;
                } else {
                    // === 松开鼠标：随机打散 ===
                    // 目标是之前计算好的随机点 (scatterTargets)
                    // 这样粒子会回到星空状态，而不是围成圆圈
                    
                    tx = sa[idx];
                    ty = sa[idx+1];
                    tz = sa[idx+2];
                    
                    // 加入一点动态漂浮，让打散后不是静止的
                    tx += Math.sin(time + i)*0.05;
                    ty += Math.cos(time + i)*0.05;

                    // 慢速飘散
                    pa[idx] += (tx - cx) * 0.04;
                    pa[idx+1] += (ty - cy) * 0.04;
                    pa[idx+2] += (tz - cz) * 0.04;
                }
            }
            geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // --- 辅助函数：点位生成 ---
        function generateBottomTextPoints(text, count) {
            const cvs = document.createElement('canvas'); cvs.width=1200; cvs.height=200;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle='#000'; ctx.fillRect(0,0,1200,200);
            ctx.fillStyle='#fff'; ctx.font='900 140px Arial'; 
            ctx.textAlign='center'; ctx.textBaseline='middle';
            ctx.fillText(text, 600, 100);
            const data = ctx.getImageData(0,0,1200,200).data;
            const validPts=[];
            for(let y=0;y<200;y+=4)for(let x=0;x<1200;x+=4)if(data[(y*1200+x)*4]>128)validPts.push({x,y});
            const points=[]; if(!validPts.length) return points;
            for(let i=0;i<count;i++){
                const p=validPts[Math.floor(Math.random()*validPts.length)];
                const xNorm=(p.x/1200)-0.5; const angle=xNorm*Math.PI*0.8; const radius=18;
                points.push({
                    x:Math.sin(angle)*radius, y:-5.0-((200-p.y)/200)*5.0, z:Math.cos(angle)*radius-radius+5,
                    r:1.0, g:0.8, b:0.1, size:CONFIG.baseSize*1.2
                });
            }
            return points;
        }

        function generateTreePoints(count) {
            const points=[];
            const cRed=new THREE.Color(CONFIG.colors.red), cGold=new THREE.Color(CONFIG.colors.gold);
            const cBlue=new THREE.Color(CONFIG.colors.blue), cWhite=new THREE.Color(CONFIG.colors.white);
            const cGreen=new THREE.Color(CONFIG.colors.green);
            
            for(let i=0;i<count*0.03;i++){
                const r=Math.random()*2, a1=Math.random()*6.28, a2=Math.random()*3.14;
                points.push({x:r*Math.sin(a2)*Math.cos(a1), y:CONFIG.treeHeight+1+r*Math.sin(a2)*Math.sin(a1), z:r*Math.cos(a2), r:1, g:1, b:0.5, size:CONFIG.baseSize*3});
            }
            const bodyCount=count*0.97; const phi=Math.PI*(3-Math.sqrt(5));
            for(let i=0;i<bodyCount;i++){
                const hRatio=i/bodyCount, y=hRatio*CONFIG.treeHeight;
                const maxR=CONFIG.treeRadius*(1-hRatio), r=Math.sqrt(Math.random())*maxR, theta=i*phi;
                let c=cGreen, s=CONFIG.baseSize;
                const isSurface=r>maxR*0.75, spiral=Math.sin(y*0.5+theta*1.5);
                if(isSurface){
                    if(spiral>0.8){c=cRed;s*=2.0;} else if(spiral<-0.8){c=cGold;s*=1.8;}
                    else if(Math.random()>0.92){c=cBlue;s*=1.6;} else if(Math.random()>0.92){c=cWhite;s*=1.5;}
                } else { c=cGreen.clone().multiplyScalar(0.6); }
                points.push({x:r*Math.cos(theta), y:y, z:r*Math.sin(theta), r:c.r, g:c.g, b:c.b, size:s});
            }
            return points;
        }

        function createShapeTexture(type) {
            const cvs=document.createElement('canvas'); cvs.width=64; cvs.height=64;
            const ctx=cvs.getContext('2d');
            const g=ctx.createRadialGradient(32,32,0,32,32,32);
            g.addColorStop(0,'white'); g.addColorStop(1,'rgba(255,255,255,0)');
            ctx.fillStyle=g; ctx.translate(32,32); ctx.beginPath();
            const r=28;
            if(type=='star'){
                for(let i=0;i<5;i++){ctx.lineTo(Math.cos((18+i*72)/180*Math.PI)*r,-Math.sin((18+i*72)/180*Math.PI)*r);ctx.lineTo(Math.cos((54+i*72)/180*Math.PI)*r*0.4,-Math.sin((54+i*72)/180*Math.PI)*r*0.4);}
            }else{
                ctx.moveTo(0,r*0.3); ctx.bezierCurveTo(0,r*0.3,-r/2,-r/2,-r,r*0.3); ctx.bezierCurveTo(-r,r,0,r*1.3,0,r*1.3); ctx.bezierCurveTo(0,r*1.3,r,r,r,r*0.3); ctx.bezierCurveTo(r,-r/2,r/2,-r/2,0,r*0.3); ctx.rotate(Math.PI);
            }
            ctx.fill(); return new THREE.CanvasTexture(cvs);
        }
    </script>
</body>
</html>